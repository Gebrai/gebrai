import { v4 as uuidv4 } from 'uuid';
import { Tool, ExecuteToolResult, Resource } from '../types';
import { logger } from '../../utils/logger';
import * as math from 'mathjs';

/**
 * Tool for creating 2D graphs
 */
export const createGraph2DTool: Tool = {
  name: 'createGraph2D',
  description: 'Create a 2D graph visualization from a mathematical expression',
  
  // Input schema (JSON Schema)
  inputSchema: {
    type: 'object',
    required: ['expression'],
    properties: {
      expression: {
        type: 'string',
        description: 'Mathematical expression to graph (e.g., "y=x^2")',
      },
      xRange: {
        type: 'array',
        items: {
          type: 'number',
        },
        minItems: 2,
        maxItems: 2,
        description: 'X-axis range [min, max]',
        default: [-10, 10],
      },
      yRange: {
        type: 'array',
        items: {
          type: 'number',
        },
        minItems: 2,
        maxItems: 2,
        description: 'Y-axis range [min, max]',
        default: [-10, 10],
      },
      title: {
        type: 'string',
        description: 'Title of the graph',
      },
      showGrid: {
        type: 'boolean',
        description: 'Whether to show grid lines',
        default: true,
      },
      showAxes: {
        type: 'boolean',
        description: 'Whether to show axes',
        default: true,
      },
      color: {
        type: 'string',
        description: 'Color of the graph (CSS color or hex)',
        default: '#FF0000',
      },
    },
  },
  
  // Output schema (JSON Schema)
  outputSchema: {
    type: 'object',
    properties: {
      visualizationId: {
        type: 'string',
        description: 'ID of the created visualization',
      },
      renderData: {
        type: 'object',
        properties: {
          format: {
            type: 'string',
            enum: ['svg', 'png', 'html'],
          },
          data: {
            type: 'string',
            description: 'Rendered visualization data (base64 encoded for binary formats)',
          },
          width: {
            type: 'number',
          },
          height: {
            type: 'number',
          },
        },
      },
      interactiveUrl: {
        type: 'string',
        description: 'URL to an interactive version of the visualization',
      },
    },
  },
  
  // Execute the tool
  execute: async (args: any): Promise<ExecuteToolResult> => {
    try {
      logger.info('Executing createGraph2D tool', { args });
      
      // Extract arguments with defaults
      const {
        expression,
        xRange = [-10, 10],
        yRange = [-10, 10],
        title = 'Graph',
        showGrid = true,
        showAxes = true,
        color = '#FF0000',
      } = args;
      
      // Generate a unique ID for the visualization
      const visualizationId = uuidv4();
      
      // In a real implementation, this would call the GeoGebra adapter
      // to create the actual visualization
      // For now, we'll create a mock result
      
      // Mock data points (in a real implementation, these would be calculated)
      const dataPoints = [];
      const [xMin, xMax] = xRange;
      const step = (xMax - xMin) / 100;
      
      // Parse the expression using mathjs (safe alternative to eval)
      const fn = expression.replace('y=', '').replace('f(x)=', '');
      
      // Prepare the expression for mathjs (replace ^ with pow)
      const safeFn = fn.replace(/\^/g, '**');
      
      // Compile the expression once for efficiency
      try {
        const compiledExpression = math.compile(safeFn);
        
        // Generate data points
        for (let x = xMin; x <= xMax; x += step) {
          try {
            // Safely evaluate the expression using mathjs
            const y = compiledExpression.evaluate({ x });
            dataPoints.push({ x, y });
          } catch (error) {
            logger.warn('Error evaluating expression at x=' + x, { error });
          }
        }
      } catch (error) {
        logger.error('Error compiling expression', { expression: safeFn, error });
        throw new Error(`Invalid mathematical expression: ${error.message}`);
      }
      
      // Create a mock SVG (in a real implementation, this would be generated by GeoGebra)
      const svgWidth = 800;
      const svgHeight = 600;
      const mockSvg = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg">
        <rect width="100%" height="100%" fill="white"/>
        <text x="10" y="20" font-family="Arial" font-size="16">${title}</text>
        <text x="10" y="40" font-family="Arial" font-size="12">${expression}</text>
        <!-- This is a mock SVG, in a real implementation this would be a proper graph -->
      </svg>`;
      
      // Create a resource for the visualization
      const resource: Resource = {
        id: visualizationId,
        type: 'visualization/2d-graph',
        data: {
          expression,
          xRange,
          yRange,
          showGrid,
          showAxes,
          color,
          dataPoints,
        },
        metadata: {
          title,
          timestamp: new Date().toISOString(),
        },
      };
      
      // Return the result
      return {
        result: {
          visualizationId,
          renderData: {
            format: 'svg',
            data: mockSvg,
            width: svgWidth,
            height: svgHeight,
          },
          interactiveUrl: `https://example.com/interactive/${visualizationId}`,
        },
        resources: [resource],
      };
    } catch (error) {
      logger.error('Error in createGraph2D tool', { error });
      
      if (error instanceof Error) {
        return {
          result: null,
          error: {
            code: 'TOOL_EXECUTION_ERROR',
            message: error.message,
            recovery: {
              recoverable: false,
              retryable: false,
            },
          },
        };
      }
      
      return {
        result: null,
        error: {
          code: 'UNKNOWN_ERROR',
          message: 'An unknown error occurred',
          recovery: {
            recoverable: false,
            retryable: false,
          },
        },
      };
    }
  },
};
